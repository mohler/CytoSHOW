package ij.plugin;

import ij.*;
import ij.process.*;
import ij.util.Tools;
import ij.plugin.FFT;
import ij.plugin.filter.Filler;
import ij.plugin.filter.GaussianBlur;
import ij.plugin.filter.RankFilters;
import ij.plugin.filter.Transformer;
import ij.gui.*;
import ij.io.FileSaver;
import ij.plugin.*;

import java.awt.Color;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.*;

/** AUTOGENERATED COMMENT LOGIC BELOW... PRETTY CLOSE TO CORRECT.
 * This plugin processes each Z-slice of an open image using a
 * fixed-size thread pool for concurrent execution. This version
 * incorporates the user's specific macro logic, including the
 * handling of intermediate image objects and saving methods,
 * while ensuring thread safety.
 *
 * To use this plugin:
 * 1. Save the code as FibsemCleanup.java in your ImageJ/plugins folder.
 * 2. Restart ImageJ. The plugin will appear in the Plugins menu.
 * 3. Open one or more images you wish to process.
 * 4. Run the plugin from the menu.
 */
public class FibsemCleanup implements PlugIn {

    @SuppressWarnings("static-access")
	@Override
    public void run(String arg) {
        // Get a list of IDs for all open images.
        int[] impIDs = WindowManager.getIDList();
        if (impIDs == null || impIDs.length == 0) {
            IJ.error("No images are open.");
            return;
        }
        
        String outliersParamsString = IJ.getString("Parameters for Remove Outliers?", " 2, 5, 1  , 50");     
        String[] outliersParamsArray = outliersParamsString.split(" *, *");
        final int outParam0 = Integer.parseInt(outliersParamsArray[0].trim());
        final int outParam1 = Integer.parseInt(outliersParamsArray[1].trim());
        final int outParam2 = Integer.parseInt(outliersParamsArray[2].trim());
        final int outParam3 = Integer.parseInt(outliersParamsArray[3].trim());
        
        String fftBlankEllipsesParamsString = IJ.getString("Parameters for EllipseRoi? x1,y1,y2,aspectRation", "864, 2051, 1980, 2051, 0.04");
        String[] fftBlankEllipsesParamsArray = fftBlankEllipsesParamsString.split(" *, *");
        final double fftParam0 = Double.parseDouble(fftBlankEllipsesParamsArray[0].trim());
        final double fftParam1 = Double.parseDouble(fftBlankEllipsesParamsArray[1].trim());
        final double fftParam2 = Double.parseDouble(fftBlankEllipsesParamsArray[2].trim());
        final double fftParam3 = Double.parseDouble(fftBlankEllipsesParamsArray[3].trim());
        final double fftParam4 = Double.parseDouble(fftBlankEllipsesParamsArray[4].trim());
       
        String claheParamsString = IJ.getString("Parameters for CLAHE? blockRadius, bins, slope ", "127, 256, 2.7f");
        String[] claheParamsArray = claheParamsString.split(" *, *");
        final int claheParam0 = Integer.parseInt(claheParamsArray[0].trim());
        final int claheParam1 = Integer.parseInt(claheParamsArray[1].trim());
        final float claheParam2 = Float.parseFloat(claheParamsArray[2].trim());
       
        String gaussParamsString = IJ.getString("Parameters for final Gaussian Blur (pixels): sigX, sigY, accuracy?", "1.333, 1.333, 0.0001");
        String[] gaussParamsArray = gaussParamsString.split(" *, *");
        final double gaussParam0 = Double.parseDouble(gaussParamsArray[0].trim());
        final double gaussParam1 = Double.parseDouble(gaussParamsArray[1].trim());
        final double gaussParam2 = Double.parseDouble(gaussParamsArray[2].trim());
       
        String rotateNewImageString = IJ.getString("Rotate final image?", "Right");
        final String rotImgString = rotateNewImageString.toLowerCase();

        // Determine the number of available processors to create an optimal-sized thread pool.
        int processors = Runtime.getRuntime().availableProcessors();
//        processors = 1;
        ExecutorService executor = Executors.newFixedThreadPool(processors);
        IJ.log("Using a thread pool with " + processors + " threads.");

        // Loop through each open image ID.
        for (int impID : impIDs) {
            WindowManager.setTempCurrentImage(WindowManager.getImage(impID));

            ImagePlus sourceImp = WindowManager.getTempCurrentImage();
            if (sourceImp == null) {
                continue; // Skip if image is no longer available
            }
            String path = IJ.getDirectory("image");
            WindowManager.setTempCurrentImage(null); // Clear the temporary current image
            
            if (path == null) {
                IJ.error("Could not determine image directory.");
                return;
            }

            
            // Get image dimensions from the source ImagePlus object.
            int zDepth = sourceImp.getNSlices();
            String sourceName = sourceImp.getTitle();

            // Create a new directory for the processed images.
            String processedDirName = sourceName.substring(0, sourceName.lastIndexOf('.')) + "_processed";
            String destDir = IJ.getDirectory("Save output where?");
            String savePath = destDir + processedDirName + File.separator;
            String destination = savePath + sourceName;

            try {
                new File(savePath).mkdirs();
            } catch (Exception e) {
                IJ.error("Could not create directory: " + savePath);
                continue;
            }
            
//            final ThreadLocal<Integer> finalThreadedZ = ThreadLocal.withInitial(() -> new Integer(1));
            final ThreadLocal<ImagePlus> sliceThreadedImp = ThreadLocal.withInitial(() -> new ImagePlus(sourceName+"_slice_XXXXXX", sourceImp.getProcessor()));
            final ThreadLocal<FFT> fwdFFT = ThreadLocal.withInitial(() -> new FFT());
            final ThreadLocal<FFT> invFFT = ThreadLocal.withInitial(() -> new FFT());
            final ThreadLocal<Toolbar> toolbarForColorSettings = ThreadLocal.withInitial(() -> new Toolbar());
            final ThreadLocal<Filler> filler = ThreadLocal.withInitial(() -> new Filler());
            final ThreadLocal<RankFilters> rankFilterA = ThreadLocal.withInitial(() -> new RankFilters());
            final ThreadLocal<RankFilters> rankFilterB = ThreadLocal.withInitial(() -> new RankFilters());
            final ThreadLocal<GaussianBlur> gaussBlur = ThreadLocal.withInitial(() -> new GaussianBlur());
            final ThreadLocal<CLAHE> claheFilter = ThreadLocal.withInitial(() -> new CLAHE());
            final ThreadLocal<ImagePlus> invFFTimp = ThreadLocal.withInitial(() -> new ImagePlus("invFFTimp" +"_XXXXXX.tif", sourceImp.getProcessor()));
            final ThreadLocal<FileSaver> tiffSaver = ThreadLocal.withInitial(() -> new FileSaver(new ImagePlus()));
            final ThreadLocal<Transformer> transformer = ThreadLocal.withInitial(() -> new Transformer());

            // Define the full path for the output file
            final ThreadLocal<String> fullThreadedOutputPath = ThreadLocal.withInitial(() -> destination.replace(".tif", "") +"_XXXXXX.tif");

            // Loop through each Z-slice and submit a processing task to the executor.
            for (int z = 1; z <= zDepth; z++) {

                String fullOutputPath = destination.replace(".tif", "") +"_"+IJ.pad(z,6)+".tif";

                // Check if the output file already exists. If so, skip processing this slice.
                if ((new File(fullOutputPath)).exists()){
                	IJ.log("Skipping slice " + z + ", output file already exists.");
                	continue; 
                }

                final int finalZ = z;

                executor.submit(() -> {
                    try {

                        // --- Processing steps as per the macro ---
                        
                        sliceThreadedImp.set(new ImagePlus(sourceName+"_slice_"+IJ.pad(finalZ, 6), sourceImp.getStack().getProcessor(finalZ)));

                        // 1. Remove Outliers (Dark and Bright)
//                        	rankFilterA.get().rank(sliceThreadedImp.get().getProcessor(), 2, RankFilters.OUTLIERS, 1, 50);
//                        	rankFilterA.get().rank(sliceThreadedImp.get().getProcessor(), 2, RankFilters.OUTLIERS, 0, 50);
	                    	rankFilterA.get().rank(sliceThreadedImp.get().getProcessor(), outParam0, outParam1, 1, outParam3);
	                    	rankFilterA.get().rank(sliceThreadedImp.get().getProcessor(), outParam0, outParam1, 0, outParam3);
                       

                        // 2. FFT
                        // The FFT command creates a new image window which we will capture.
                           fwdFFT.get().setImp(sliceThreadedImp.get());
                           fwdFFT.get().run("fft hide");
//                           ImagePlus fftFwdImp = WindowManager.getCurrentImage();
//                           fftFwdImp.hide();
                        // 3. Clear elliptical regions in FFT image
                           
                            fwdFFT.get().getFwdFHT().getProcessor().setColor(Color.black);
                            final int fftScaleFactor = fwdFFT.get().getFwdFHT().getWidth()/4096;
                            
//                            fwdFFT.get().getFwdFHT().getProcessor().fill(new EllipseRoi(864, 2051, 1980, 2051, 0.04)); // fill with black color
                            fwdFFT.get().getFwdFHT().getProcessor().fill(new EllipseRoi(fftParam0*fftScaleFactor, 
                            															fftParam1*fftScaleFactor, 
                            															fftParam2*fftScaleFactor, 
                            															fftParam3*fftScaleFactor, 
                            															fftParam4)); // fill with black color
                            fwdFFT.get().getFwdFHT().getProcessor().setColor(Color.black);
                            fwdFFT.get().getFwdFHT().getProcessor().fill(new EllipseRoi(fwdFFT.get().getFwdFHT().getWidth() - fftParam0*fftScaleFactor, 
                            														     fftParam1*fftScaleFactor, 
                            														     fwdFFT.get().getFwdFHT().getWidth() - fftParam2*fftScaleFactor, 
                            														     fftParam3*fftScaleFactor, 
                            														     fftParam4)); // fill with black color
                            fwdFFT.get().getFwdFHT().killRoi();

                        // 4. Inverse FFT
                        
                            invFFT.get().setImp(fwdFFT.get().getFwdFHT());
                            invFFT.get().run("inverse hide");
                        if (invFFT.get().getInvFHT() == null) {
                            IJ.error("Inverse FFT failed for slice " + finalZ);
                                fwdFFT.get().getImp().close();
                                fwdFFT.get().getFwdFHT().close();
                                sliceThreadedImp.get().close();
                            
                            return;
                        }
                        invFFTimp.set(new ImagePlus("invFFTimp" +"_"+IJ.pad(finalZ,6)+".tif",invFFT.get().getInvFHT().getProcessor()));
                        
                        // 5. Enhance Local Contrast (CLAHE)
                        
//                            claheFilter.get().run(invFFTimp.get(), 127, 256, 2.7f, null, null);
                        claheFilter.get().run(invFFTimp.get(), claheParam0, claheParam1, claheParam2, null, null);
                        
                            
                        // 6. Remove Outliers (Dark and Bright) - Second pass
                    		rankFilterB.get().rank(invFFTimp.get().getProcessor(),  outParam0, outParam1, 1, outParam3);
                    		rankFilterB.get().rank(invFFTimp.get().getProcessor(),  outParam0, outParam1, 0, outParam3);
                        
                        
                        // 7. Gaussian Blur
//                            gaussBlur.get().blurGaussian(invFFTimp.get().getProcessor(), 1.333, 1.333, 0.0001);
                            gaussBlur.get().blurGaussian(invFFTimp.get().getProcessor(), gaussParam0, gaussParam1, gaussParam2);

                    		
                        // 8. Rotate right 90%
//                            transformer.get().setup("right", invFFTimp.get());
                            transformer.get().setup(rotImgString, invFFTimp.get());
                            transformer.get().run(null);
                        
                        
                        // 9. Save the processed slice.
                            tiffSaver.set(new FileSaver(invFFTimp.get()));
                            fullThreadedOutputPath.set(destination.replace(".tif", "") +"_"+IJ.pad(finalZ,6)+".tif");
                            tiffSaver.get().saveAsTiff(fullThreadedOutputPath.get());
                        
                        
                        // Close the temporary images to free up memory.
                            sliceThreadedImp.get().close();
                            invFFTimp.get().close();
                            IJ.log("finished slice "+finalZ);
                        
                    } catch (Exception e) {
                        IJ.error("Error processing slice " + finalZ + ": " + e.getMessage());
                    }
                });
            }
        }

        // Shut down the executor and wait for all tasks to complete.
        executor.shutdown();
        try {
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
            IJ.error("Plugin execution was interrupted.");
        }
        IJ.log("Plugin execution complete.");
    }
}
